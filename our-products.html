<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Our Products</title>
  <style>
    /* CSS unchanged */
    :root {
      --color-background: #ffffff;
      --color-foreground: #f8f9fa;
      --color-text: #222;
      --color-secondary: #666;
      --color-primary: #007bff;
      --color-primary-hover: #0056b3;
      --color-border-subtle: #e9ecef;

      --font-family-sans-serif: system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
      --font-weight-normal: 400;
      --font-weight-bold: 600;

      --transition-speed: 0.2s;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: var(--font-family-sans-serif);
      font-size: 1rem;
      line-height: 1.5;
      color: var(--color-text);
      background-color: var(--color-background);
    }

    .category-list {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.5rem;
      padding: 0.8rem;
      background: var(--color-foreground);
      border-bottom: 1px solid var(--color-border-subtle);
    }

    .category-list button {
      background: #fff;
      border: 1px solid var(--color-border-subtle);
      border-radius: 18px;
      padding: 0.4rem 1rem;
      font-size: 0.85rem;
      color: var(--color-text);
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .category-list button:hover,
    .category-list button.active {
      background: var(--color-primary);
      color: #fff;
      border-color: var(--color-primary);
    }

    .product-grid {
      display: flex;
      flex-wrap: wrap;
      justify-content: center;
      gap: 0.8rem;
      padding: 1rem;
    }

    .product-card {
      background: #fff;
      border-radius: 6px;
      border: 1px solid var(--color-border-subtle);
      overflow: hidden;
      transition: transform 0.2s ease;
      cursor: pointer;
      flex: 1 1 150px;
      max-width: 150px;
      display: flex;
      flex-direction: column;
    }

    .product-card:hover {
      transform: translateY(-3px);
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }

    .product-card img {
      width: 100%;
      height: 120px;
      object-fit: cover;
      background: #f3f3f3;
    }

    .product-info {
      padding: 0.5rem;
      display: flex;
      flex-direction: column;
      gap: 0.25rem;
    }

    .product-info h3 {
      font-size: 0.9rem;
      margin: 0;
      color: var(--color-text);
      font-weight: 500;
      line-height: 1.2;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .product-info .colors {
      font-size: 0.75rem;
      color: var(--color-secondary);
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .product-info p {
      font-size: 0.95rem;
      font-weight: 600;
      margin: 0.1rem 0 0;
      color: #000;
    }

    @media (min-width: 768px) {
      .product-card {
        flex: 1 1 220px;
        max-width: 220px;
      }

      .product-card img {
        height: 180px;
      }

      .product-info h3 {
        font-size: 1rem;
      }

      .product-info p {
        font-size: 1rem;
      }
    }
  </style>
</head>
<body>
  <div id="navbar-placeholder"></div>

  <div class="category-list" id="categoryList"></div>

  <div class="product-grid" id="productGrid"></div>

  <script>
    fetch('navbar.html')
      .then(res => res.text())
      .then(data => {
        document.getElementById('navbar-placeholder').innerHTML = data;
        const navbarToggle = document.getElementById('navbarToggle');
        const navbarMenu = document.getElementById('navbarMenu');
        if (navbarToggle && navbarMenu) {
          navbarToggle.addEventListener('click', () => {
            navbarToggle.classList.toggle('is-active');
            navbarMenu.classList.toggle('is-active');
          });
        }
      });

    let productsData = [];
    let optionsData = [];
    let currentCategory = 'all';

    async function fetchData() {
      const productsRes = await fetch('products.json');
      const optionsRes = await fetch('options.json');
      productsData = await productsRes.json();
      optionsData = await optionsRes.json();

      renderCategories(optionsData.categories || []);
      renderProducts(productsData, optionsData);
    }

    // Helpers to robustly extract numeric base prices and percentages
    function getMaterialBasePrice(options, key) {
      if (!key) return 0;
      const opt = options[key];
      if (opt == null) return 0;
      // If option is an object with .price
      if (typeof opt === 'object' && opt.price != null && typeof opt.price === 'number') return opt.price;
      // If option itself is a number (rare)
      if (typeof opt === 'number') return opt;
      // fallback 0
      return 0;
    }

    function getColorBasePrices(options, colorGroupName) {
      // colors groups in options are plain objects mapping colorName -> number
      const group = options[colorGroupName];
      if (group && typeof group === 'object') return group;
      return {};
    }

    function getPercentageFromValue(val) {
      // val might be: { price: { percentage: X } }, or { percentage: X }, or a number X
      if (val == null) return 100;
      if (typeof val === 'object') {
        if (val.price && typeof val.price.percentage === 'number') return val.price.percentage;
        if (typeof val.percentage === 'number') return val.percentage;
      }
      if (typeof val === 'number') return val;
      return 100; // default if nothing specified
    }

    // Generic accessory unit price finder (finds the cheapest unit price in options[accessoryKey])
    function getAccessoryUnitPrice(options, accessoryKey) {
      const opt = options[accessoryKey];
      if (opt == null) return 0;
      if (typeof opt === 'number') return opt;
      if (typeof opt === 'object') {
        // Values could be numbers (e.g., { normal: 10, soft close: 20 })
        const vals = Object.values(opt).filter(v => typeof v === 'number');
        if (vals.length === 0) return 0;
        return Math.min(...vals);
      }
      return 0;
    }

    // Main generic calculation:
    // - supports any number of "type ..." keys
    // - each type sums all material entries (non-color keys) using percentage * material base price
    // - for color groups inside a type: supports single color entries and combo entries that are arrays of parts
    // - picks the cheapest type and then adds all accessories found at product top-level that match options and have quantity
    function calculateCheapestPrice(product, options) {
      let cheapestTypeCost = Infinity;
      let chosenTypeKey = null;
      let chosenCheapestColorName = null;

      // find type keys dynamically (keys that start with "type" case-insensitive)
      const typeKeys = Object.keys(product).filter(k => /^type\b/i.test(k.trim()));

      for (const typeKey of typeKeys) {
        const typeData = product[typeKey];
        if (!typeData || typeof typeData !== 'object') continue;

        let materialSum = 0;

        // Collect color group names found in this type (any key containing 'color')
        const colorGroupNames = [];

        for (const [matKey, matVal] of Object.entries(typeData)) {
          if (matKey.toLowerCase().includes('color')) {
            colorGroupNames.push(matKey);
            continue;
          }
          // treat as material
          const basePrice = getMaterialBasePrice(options, matKey);
          const percentage = getPercentageFromValue(matVal);
          materialSum += (basePrice * percentage) / 100;
        }

        // Determine total color cost by summing cheapest color (or combo) in each group
        let totalColorCost = 0;
        const cheapestNamesForGroups = [];

        for (const colorGroupName of colorGroupNames) {
          const colorsObj = typeData[colorGroupName] || {};
          const baseColorPrices = getColorBasePrices(options, colorGroupName);

          let cheapestInGroupCost = Infinity;
          let cheapestInGroupName = null;

          for (const [colorKey, colorVal] of Object.entries(colorsObj)) {
            // compute colorCost for this entry (supports arrays of parts or single entries)
            let colorCost = 0;

            // Case A: array of parts (e.g., "white + white": [ {percentage, color}, {percentage, color} ])
            if (Array.isArray(colorVal)) {
              for (const part of colorVal) {
                const partPct = getPercentageFromValue(part) / 100;
                const partColorName = (part && part.color) ? part.color : colorKey;
                const partBasePrice = baseColorPrices[partColorName] != null ? baseColorPrices[partColorName] : 0;
                colorCost += partBasePrice * partPct;
              }
            } else if (typeof colorVal === 'object') {
              // Case B: single object like { percentage: 70 } or { price: { percentage: 70 } }
              const pct = getPercentageFromValue(colorVal) / 100;
              // for single entries, colorKey should be the color name (e.g., "white")
              const base = baseColorPrices[colorKey] != null ? baseColorPrices[colorKey] : 0;
              colorCost = base * pct;
            } else if (typeof colorVal === 'number') {
              // Case C: direct numeric percentage
              const pct = colorVal / 100;
              const base = baseColorPrices[colorKey] != null ? baseColorPrices[colorKey] : 0;
              colorCost = base * pct;
            } else {
              // unknown shape -> skip (cost 0)
              colorCost = 0;
            }

            if (colorCost < cheapestInGroupCost) {
              cheapestInGroupCost = colorCost;
              cheapestInGroupName = colorKey;
            }
          }

          if (cheapestInGroupCost === Infinity) cheapestInGroupCost = 0;
          totalColorCost += cheapestInGroupCost;
          if (cheapestInGroupName) cheapestNamesForGroups.push(cheapestInGroupName);
        }

        // If no color groups, color cost is 0
        if (totalColorCost === 0 && colorGroupNames.length === 0) {
          totalColorCost = 0;
        }

        const totalTypeCost = materialSum + totalColorCost;

        if (totalTypeCost < cheapestTypeCost) {
          cheapestTypeCost = totalTypeCost;
          chosenTypeKey = typeKey;
          chosenCheapestColorName = cheapestNamesForGroups.length ? cheapestNamesForGroups.join(', ') : null;
        }
      }

      // If no type keys found, fallback: attempt to treat the product as a single unnamed type
      if (cheapestTypeCost === Infinity) {
        // try to sum top-level material-like keys (defensive)
        let materialSum = 0;
        const colorGroupNames = [];
        for (const [key, val] of Object.entries(product)) {
          if (['id','name','category','images'].includes(key)) continue;
          if (key.toLowerCase().includes('color')) { colorGroupNames.push(key); continue; }
          if (val && val.quantity != null) continue; // skip accessories
          const basePrice = getMaterialBasePrice(options, key);
          const percentage = getPercentageFromValue(val);
          materialSum += (basePrice * percentage) / 100;
        }
        let totalColorCost = 0;
        const cheapestNamesForGroups = [];
        for (const colorGroupName of colorGroupNames) {
          const colorsObj = product[colorGroupName] || {};
          const baseColorPrices = getColorBasePrices(options, colorGroupName);
          let cheapestInGroupCost = Infinity;
          let cheapestInGroupName = null;
          for (const [colorKey, colorVal] of Object.entries(colorsObj)) {
            let colorCost = 0;
            if (Array.isArray(colorVal)) {
              for (const part of colorVal) {
                const partPct = getPercentageFromValue(part) / 100;
                const partColorName = (part && part.color) ? part.color : colorKey;
                const partBasePrice = baseColorPrices[partColorName] != null ? baseColorPrices[partColorName] : 0;
                colorCost += partBasePrice * partPct;
              }
            } else if (typeof colorVal === 'object') {
              const pct = getPercentageFromValue(colorVal) / 100;
              const base = baseColorPrices[colorKey] != null ? baseColorPrices[colorKey] : 0;
              colorCost = base * pct;
            } else if (typeof colorVal === 'number') {
              const pct = colorVal / 100;
              const base = baseColorPrices[colorKey] != null ? baseColorPrices[colorKey] : 0;
              colorCost = base * pct;
            } else {
              colorCost = 0;
            }

            if (colorCost < cheapestInGroupCost) {
              cheapestInGroupCost = colorCost;
              cheapestInGroupName = colorKey;
            }
          }
          if (cheapestInGroupCost === Infinity) cheapestInGroupCost = 0;
          totalColorCost += cheapestInGroupCost;
          if (cheapestInGroupName) cheapestNamesForGroups.push(cheapestInGroupName);
        }
        if (totalColorCost === 0 && colorGroupNames.length === 0) totalColorCost = 0;
        cheapestTypeCost = materialSum + totalColorCost;
        chosenCheapestColorName = cheapestNamesForGroups.length ? cheapestNamesForGroups.join(', ') : null;
      }

      // Accessories: find top-level keys that look like accessories (have .quantity) AND exist in options
      let accessoryTotal = 0;
      for (const [key, val] of Object.entries(product)) {
        if (val && typeof val === 'object' && Number.isFinite(val.quantity)) {
          // only if options has a matching accessory definition
          if (options[key] != null) {
            const unitPrice = getAccessoryUnitPrice(options, key);
            accessoryTotal += unitPrice * Number(val.quantity);
          }
        }
      }

      const finalTotal = Number(cheapestTypeCost || 0) + Number(accessoryTotal || 0);
      return {
        price: finalTotal.toFixed(2),
        cheapestColor: chosenCheapestColorName || null,
        chosenType: chosenTypeKey || null
      };
    }

    function renderCategories(categories) {
      const container = document.getElementById('categoryList');
      container.innerHTML = '';

      const allBtn = document.createElement('button');
      allBtn.textContent = 'All';
      allBtn.classList.add('active');
      allBtn.onclick = () => filterByCategory('all');
      container.appendChild(allBtn);

      categories.forEach(cat => {
        const btn = document.createElement('button');
        btn.textContent = cat;
        btn.onclick = () => filterByCategory(cat);
        container.appendChild(btn);
      });
    }

    function filterByCategory(category) {
      currentCategory = category;
      const buttons = document.querySelectorAll('.category-list button');
      buttons.forEach(btn => btn.classList.remove('active'));
      const activeBtn = [...buttons].find(btn => btn.textContent.toLowerCase() === (category === 'all' ? 'all' : category.toLowerCase()));
      if (activeBtn) activeBtn.classList.add('active');

      const filtered = category === 'all'
        ? productsData
        : productsData.filter(p => p.category.toLowerCase() === category.toLowerCase());

      renderProducts(filtered, optionsData);
    }

    function renderProducts(products, options) {
      const grid = document.getElementById('productGrid');
      grid.innerHTML = '';

      products.forEach(product => {
        const calc = calculateCheapestPrice(product, options);
        const cheapestPrice = calc.price;
        const firstImage = Object.values(product.images)[0] || 'https://via.placeholder.com/220x180?text=No+Image';

        const colorNames = new Set();
        ['type 1', 'type 2'].forEach(typeKey => {
          if (product[typeKey]) {
            for (const [key, val] of Object.entries(product[typeKey])) {
              if (key.toLowerCase().includes('color')) {
                Object.keys(val).forEach(color => colorNames.add(color));
              }
            }
          }
        });
        // Also check for top-level color groups if any
        for (const [k, v] of Object.entries(product)) {
          if (k.toLowerCase().includes('color') && typeof v === 'object') {
            Object.keys(v).forEach(color => colorNames.add(color));
          }
        }

        const uniqueColors = Array.from(colorNames);

        const colorDisplay = uniqueColors.length > 2
          ? `${uniqueColors.slice(0, 2).join(', ')} +${uniqueColors.length - 2} more`
          : uniqueColors.join(', ');

        const card = document.createElement('div');
        card.className = 'product-card';
        card.onclick = () => {
          window.location.href = `product-detail.html?id=${product.id}`;
        };
        card.innerHTML = `
          <img src="${firstImage}" alt="${product.name}">
          <div class="product-info">
            <h3>${product.name}</h3>
            <div class="colors">${colorDisplay}</div>
            <p>RM ${cheapestPrice}</p>
          </div>
        `;
        grid.appendChild(card);
      });
    }

    fetchData();
  </script>
</body>
</html>
