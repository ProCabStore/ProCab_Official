<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Product Detail</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.css"/>
  <style>
    * { box-sizing: border-box; }
    html, body { width: 100%; margin: 0; padding: 0; overflow-x: hidden; }
    img { max-width: 100%; height: auto; display: block; }

    :root{
      --bg: #f4f5f7;
      --card: #ffffff;
      --muted: #6b7280;
      --accent: #111827;
      --border: #e6e7ea;
      --pill-bg: #f8f9fb;
      --radius: 12px;
      --gap: 0.6rem;
    }

    html,body{
      height:100%;
      background:var(--bg);
      font-family: 'Inter', 'Segoe UI', system-ui, -apple-system, "Helvetica Neue", Arial;
      color: #111;
      -webkit-font-smoothing:antialiased;
      -moz-osx-font-smoothing:grayscale;
    }

    .wrap {
      max-width: 980px;
      width: 100%;
      margin: 18px auto;
      padding: 12px;
    }

    .card {
      background: var(--card);
      border-radius: var(--radius);
      box-shadow: 0 6px 20px rgba(15, 23, 42, 0.06);
      overflow: hidden;
      display: grid;
      grid-template-columns: 1fr;
      width: 100%;
      min-width: 0;
    }

    @media (min-width: 820px) {
      .card {
        grid-template-columns: 1fr 1fr;
        min-height: 520px;
      }
    }

    .image-wrapper {
      padding: 18px;
      display:flex;
      justify-content:center;
      align-items:center;
      background: #fafafa;
      border-bottom: 1px solid var(--border);
      min-width: 0;
    }

    @media (min-width: 820px) {
      .image-wrapper {
        padding: 24px;
        border-right: 1px solid var(--border);
        border-bottom: none;
      }
    }

    .image-wrapper .swiper {
      width: 94%;
      max-width: 420px;
      box-sizing: border-box;
    }
    .image-wrapper .swiper-slide {
      display:flex;
      justify-content:center;
      align-items:center;
    }
    .image-wrapper .swiper-slide img {
      max-width: 100%;
      height: auto;
      aspect-ratio: 1/1;
      object-fit: contain;
      border-radius: 8px;
      transition: opacity .2s ease;
      display: block;
    }

    .swiper-button-next, .swiper-button-prev {
      color: rgba(0,0,0,0.8);
    }
    .swiper-pagination-bullet {
      background: rgba(0,0,0,0.35);
      opacity: 0.9;
    }

    .details {
      padding: 16px;
      display:flex;
      flex-direction:column;
      gap: 10px;
      min-width: 0;
      word-break: break-word;
    }

    .product-header {
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap: 12px;
    }

    .product-title {
      font-size: 1.125rem;
      font-weight: 700;
      margin: 0;
      color: var(--accent);
      line-height: 1.15;
      word-break: break-word;
    }

    .price {
      font-size: 1rem;
      font-weight: 700;
      color: #000;
      margin: 0;
      white-space: nowrap;
    }

    .section { margin-top: 6px; }

    .section h4 {
      font-size: 0.82rem;
      margin: 0 0 8px 0;
      color: var(--muted);
      font-weight: 700;
    }

    .select-wrapper {
      position: relative;
      width: 100%;
    }

    .select-wrapper select {
      width: 100%;
      padding: 10px 12px;
      border: 1px solid #d1d5db;
      border-radius: 8px;
      background-color: #f8f9fb;
      font-size: 0.9rem;
      color: #111827;
      appearance: none;
      -webkit-appearance: none;
      -moz-appearance: none;
      cursor: pointer;
      transition: border-color 0.2s ease;
    }

    .select-wrapper select:focus {
      outline: none;
      border-color: #9ca3af;
    }

    .select-wrapper::after {
      content: "â–¼";
      font-size: 0.7rem;
      position: absolute;
      right: 12px;
      top: 50%;
      transform: translateY(-50%);
      pointer-events: none;
      color: #6b7280;
    }

    #materialList {
      font-size: 0.90rem;
      color: #374151;
      line-height: 1.45;
    }

    .action-buttons {
      display:flex;
      gap: 10px;
      margin-top: 12px;
      align-items: center;
      flex-wrap: wrap;
    }
    .btn {
      display:flex;
      align-items:center;
      justify-content:center;
      border-radius: 10px;
      font-weight:700;
      text-decoration:none;
      border: none;
      min-width: 0;
    }
    .btn-back {
      flex: 0 0 34%;
      background: #fff;
      color: #111827;
      border: 1px solid #d1d5db;
      height:44px;
    }
    .btn-proceed {
      flex: 1;
      background: #111827;
      color: #fff;
      height:44px;
      opacity: .5;
      cursor: not-allowed;
      text-align: center;
    }
    .btn-proceed.enabled {
      opacity: 1;
      cursor: pointer;
    }

    @media (max-width:420px) {
      .wrap {
        max-width: 100%;
        margin: 0;
        padding: 10px;
      }
      .card {
        border-radius: 0;
      }
      .product-title { font-size: 1rem; }
      .price { font-size: 0.95rem; }
      .details { padding: 12px; }
      .image-wrapper { padding: 12px; }
      .action-buttons .btn-back { flex-basis: 46%; }
      .action-buttons .btn-proceed { flex-basis: 48%; }
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <div class="image-wrapper">
        <div class="swiper mySwiper" aria-label="Product images">
          <div class="swiper-wrapper" id="productImageCarousel"></div>
          <div class="swiper-button-next" aria-hidden="true"></div>
          <div class="swiper-button-prev" aria-hidden="true"></div>
          <div class="swiper-pagination" aria-hidden="true"></div>
        </div>
      </div>

      <div class="details">
        <div class="product-header">
          <h1 class="product-title" id="productName"></h1>
          <p class="price">RM <span id="price">0.00</span></p>
        </div>

        <div class="section">
          <h4>Material Type</h4>
          <div class="select-wrapper">
            <select id="typeOptions"></select>
          </div>
        </div>

        <div class="section">
          <h4>Materials</h4>
          <div id="materialList"></div>
        </div>

        <div class="section" id="colorSection">
          <h4>Color</h4>
          <div class="select-wrapper">
            <select id="colorOptions"></select>
          </div>
        </div>

        <div id="accessoriesContainer"></div>

        <div class="action-buttons">
          <a href="our-products.html" class="btn btn-back">&larr; Back</a>
          <a id="whatsappBtn" class="btn btn-proceed" href="#" target="_blank">Proceed to Order</a>
        </div>
      </div>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/swiper@11/swiper-bundle.min.js"></script>

  <script>
    const urlParams = new URLSearchParams(window.location.search);
    const productId = urlParams.get('id');
    let productData = null;
    let optionsData = null;

    let selectedType = null;
    let selectedColor = null;
    let selectedAccessories = {};

    let swiper = null;

    async function fetchData() {
      try {
        const productRes = await fetch('products.json');
        const optionsRes = await fetch('options.json');
        const products = await productRes.json();
        optionsData = await optionsRes.json();

        productData = products.find(p => p.id === productId);
        if (!productData) {
          document.querySelector('.details').innerHTML = '<p>Product not found.</p>';
          return;
        }

        renderProduct();
      } catch (error) {
        console.error('Error loading data:', error);
        document.querySelector('.details').innerHTML = '<p>Error loading product data.</p>';
      }
    }

    function renderProduct() {
      document.getElementById('productName').textContent = productData.name;
      initProductCarousel(productData);
      renderTypeOptions();
      renderAccessories();
      updatePrice();
      validateProceedButton();
    }

    function getAllTypes() {
      return Object.keys(productData).filter(key => key.toLowerCase().startsWith('type'));
    }

    const typeNameMap = {
      'type 1': 'Melamine Chipboard',
      'type 2': 'Blockboard + Formica',
    };

    function renderTypeOptions() {
      const container = document.getElementById('typeOptions');
      container.innerHTML = '';

      const typeKeys = getAllTypes();
      if(typeKeys.length === 0) return;

      // Find the cheapest type
      let cheapestType = null;
      let cheapestPrice = Infinity;

      typeKeys.forEach(typeKey => {
        const typeData = productData[typeKey];
        let typePrice = 0;
        
        // Calculate material price
        for (const [materialKey, materialVal] of Object.entries(typeData)) {
          if (materialKey.toLowerCase().includes('color')) continue;
          const basePrice = getMaterialBasePrice(materialKey);
          const pct = getPercentageFromValue(materialVal) / 100;
          typePrice += basePrice * pct;
        }

        // Find cheapest color for this type
        const colorGroupEntries = Object.entries(typeData).filter(([k]) => k.toLowerCase().includes('color'));
        for (const [colorGroupName, colorsObj] of colorGroupEntries) {
          const baseColorPrices = getColorBasePrices(colorGroupName);
          let cheapestColorPrice = Infinity;
          
          for (const [colorKey, colorVal] of Object.entries(colorsObj)) {
            const cost = computeColorEntryCost(colorKey, colorVal, baseColorPrices);
            if (cost < cheapestColorPrice) cheapestColorPrice = cost;
          }
          
          typePrice += (cheapestColorPrice === Infinity) ? 0 : cheapestColorPrice;
        }

        if (typePrice < cheapestPrice) {
          cheapestPrice = typePrice;
          cheapestType = typeKey;
        }
      });

      // Add options
      typeKeys.forEach(typeKey => {
        const displayName = typeNameMap[typeKey] || typeKey;
        const option = document.createElement('option');
        option.value = typeKey;
        option.textContent = displayName;
        container.appendChild(option);
      });

      // Auto-select cheapest type
      if (cheapestType) {
        container.value = cheapestType;
        selectedType = cheapestType;
        
        // Render materials and colors for this type
        renderMaterialList(selectedType);
        renderColorOptions(selectedType);
        
        // Update price and image
        updatePrice();
        updateMainImage(selectedColor);
      }

      container.addEventListener('change', (e) => {
        selectedType = e.target.value;
        renderMaterialList(selectedType);
        renderColorOptions(selectedType);
        updatePrice();
        updateMainImage(selectedColor);
        validateProceedButton();
      });
    }

    function renderMaterialList(typeKey) {
      const container = document.getElementById('materialList');
      container.innerHTML = '';

      const typeData = productData[typeKey];
      const materialEntries = Object.entries(typeData).filter(([key]) => !key.toLowerCase().includes('color'));

      if(materialEntries.length === 0) {
        container.textContent = 'No materials found.';
        return;
      }

      const ul = document.createElement('ul');
      ul.style.paddingLeft = '18px';
      ul.style.margin = '0';
      ul.style.color = '#374151';
      ul.style.fontSize = '0.95rem';
      ul.style.lineHeight = '1.45';

      materialEntries.forEach(([materialName]) => {
        const li = document.createElement('li');
        li.textContent = materialName;
        ul.appendChild(li);
      });

      container.appendChild(ul);
    }

    function getColorsForType(typeKey) {
      const typeData = productData[typeKey];
      const colorGroups = Object.entries(typeData).filter(([key]) => key.toLowerCase().includes('color'));
      if (colorGroups.length === 0) return [];

      const colorsSet = new Set();
      colorGroups.forEach(([_, colorsObj]) => {
        Object.keys(colorsObj).forEach(colorKey => colorsSet.add(colorKey));
      });
      return Array.from(colorsSet);
    }

    function renderColorOptions(typeKey) {
      const container = document.getElementById('colorOptions');
      container.innerHTML = '';

      const colors = getColorsForType(typeKey);
      if(colors.length === 0) {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'No colors available';
        container.appendChild(option);
        return;
      }

      // Find cheapest color
      const typeData = productData[typeKey];
      const colorGroupEntries = Object.entries(typeData).filter(([k]) => k.toLowerCase().includes('color'));
      let cheapestColor = null;
      let cheapestColorPrice = Infinity;

      for (const [colorGroupName, colorsObj] of colorGroupEntries) {
        const baseColorPrices = getColorBasePrices(colorGroupName);
        
        for (const [colorKey, colorVal] of Object.entries(colorsObj)) {
          const cost = computeColorEntryCost(colorKey, colorVal, baseColorPrices);
          if (cost < cheapestColorPrice) {
            cheapestColorPrice = cost;
            cheapestColor = colorKey;
          }
        }
      }

      // Auto-select cheapest color
      if (cheapestColor) {
        selectedColor = cheapestColor;
      } else {
        selectedColor = colors[0];
      }

      colors.forEach(colorKey => {
        const option = document.createElement('option');
        option.value = colorKey;
        option.textContent = colorKey;
        option.selected = (colorKey === selectedColor);
        container.appendChild(option);
      });

      container.addEventListener('change', (e) => {
        selectedColor = e.target.value;
        updatePrice();
        updateMainImage(selectedColor);
        validateProceedButton();
      });
    }

    function renderAccessories() {
      const accessoriesContainer = document.getElementById('accessoriesContainer');
      accessoriesContainer.innerHTML = '';

      const excludedKeys = ['id', 'name', 'images'];
      const typeKeys = getAllTypes();
      const accessoryKeys = Object.keys(productData).filter(key =>
        !excludedKeys.includes(key) && !typeKeys.includes(key)
      );

      if(accessoryKeys.length === 0) return;

      accessoryKeys.forEach(accessoryKey => {
        const accessoryData = productData[accessoryKey];
        const optionPrices = optionsData.accessory[accessoryKey];
        if(!accessoryData || !optionPrices) return;

        const section = document.createElement('div');
        section.className = 'section';
        section.id = accessoryKey + 'Section';

        const heading = document.createElement('h4');
        heading.textContent = toTitleCase(accessoryKey.replace(/([A-Z])/g, ' $1'));
        section.appendChild(heading);

        const selectWrapper = document.createElement('div');
        selectWrapper.className = 'select-wrapper';
        
        const select = document.createElement('select');
        select.id = accessoryKey + 'Options';
        section.appendChild(selectWrapper);
        selectWrapper.appendChild(select);

        accessoriesContainer.appendChild(section);

        const quantity = accessoryData.quantity || 1;
        const cheapestPrice = Math.min(...Object.values(optionPrices));

        Object.entries(optionPrices).forEach(([type, basePrice]) => {
          const diffPrice = (basePrice - cheapestPrice) * quantity;
          const option = document.createElement('option');
          option.value = type;
          option.textContent = diffPrice > 0
            ? `${type} (+RM${diffPrice.toFixed(2)})`
            : `${type}`;
          select.appendChild(option);
        });

        // Default select cheapest
        const cheapestType = Object.entries(optionPrices).reduce((min, cur) => cur[1] < min[1] ? cur : min)[0];
        selectedAccessories[accessoryKey] = cheapestType;
        
        select.addEventListener('change', (e) => {
          selectedAccessories[accessoryKey] = e.target.value;
          updatePrice();
          validateProceedButton();
        });

        // Set initial selection
        setTimeout(() => {
          select.value = cheapestType;
        }, 10);
      });
    }

    function getMaterialBasePrice(materialKey) {
      if (!materialKey || !optionsData) return 0;
      const opt = optionsData.material[materialKey];
      if (opt == null) return 0;
      if (typeof opt.price === 'number') return opt.price;
      return 0;
    }

    function getColorBasePrices(colorGroupName) {
      if (!colorGroupName || !optionsData) return {};
      const group = optionsData.colors[colorGroupName];
      if (group && typeof group === 'object') return group;
      return {};
    }

    function getPercentageFromValue(val) {
      if (val == null) return 100;
      if (typeof val === 'object') {
        if (val.price && typeof val.price.percentage === 'number') return val.price.percentage;
        if (typeof val.percentage === 'number') return val.percentage;
      }
      if (typeof val === 'number') return val;
      return 100;
    }

    function getAccessoryUnitPriceFromSelection(accessoryKey, selectedOptionName) {
      if (!optionsData || !accessoryKey) return 0;
      const opt = optionsData.accessory[accessoryKey];
      if (!opt) return 0;
      if (typeof opt === 'number') return opt;
      if (typeof opt === 'object') {
        const val = opt[selectedOptionName];
        if (typeof val === 'number') return val;
        const numeric = Object.values(opt).filter(v => typeof v === 'number');
        if (numeric.length) return Math.min(...numeric);
      }
      return 0;
    }

    function computeColorEntryCost(colorKey, colorVal, baseColorPrices) {
      let cost = 0;

      if (Array.isArray(colorVal)) {
        for (const part of colorVal) {
          const partPct = getPercentageFromValue(part) / 100;
          const partColorName = (part && part.color) ? part.color : (colorKey.includes('+') ? colorKey.split('+')[0].trim() : colorKey);
          const partBase = baseColorPrices[partColorName] != null ? baseColorPrices[partColorName] : 0;
          cost += partBase * partPct;
        }
        return cost;
      }

      if (typeof colorVal === 'object') {
        const pct = getPercentageFromValue(colorVal) / 100;
        const base = baseColorPrices[colorKey] != null ? baseColorPrices[colorKey] : 0;
        return base * pct;
      }

      if (typeof colorVal === 'number') {
        const pct = colorVal / 100;
        const base = baseColorPrices[colorKey] != null ? baseColorPrices[colorKey] : 0;
        return base * pct;
      }

      return 0;
    }

    function updatePrice() {
      if (!selectedType) return;

      const typeData = productData[selectedType] || {};

      let materialCost = 0;
      for (const [materialKey, materialVal] of Object.entries(typeData)) {
        if (materialKey.toLowerCase().includes('color')) continue;
        const basePrice = getMaterialBasePrice(materialKey);
        const pct = getPercentageFromValue(materialVal) / 100;
        materialCost += basePrice * pct;
      }

      let colorCost = 0;
      const colorGroupEntries = Object.entries(typeData).filter(([k]) => k.toLowerCase().includes('color'));
      for (const [colorGroupName, colorsObj] of colorGroupEntries) {
        const baseColorPrices = getColorBasePrices(colorGroupName);
        if (selectedColor && colorsObj[selectedColor]) {
          const selColorVal = colorsObj[selectedColor];
          colorCost += computeColorEntryCost(selectedColor, selColorVal, baseColorPrices);
          continue;
        }

        let cheapestInGroup = Infinity;
        for (const [colorKey, colorVal] of Object.entries(colorsObj)) {
          const cost = computeColorEntryCost(colorKey, colorVal, baseColorPrices);
          if (cost < cheapestInGroup) cheapestInGroup = cost;
        }
        if (cheapestInGroup === Infinity) cheapestInGroup = 0;
        colorCost += cheapestInGroup;
      }

      let accessoriesTotal = 0;
      for (const [accKey, accSelectedOptionName] of Object.entries(selectedAccessories)) {
        const qty = (productData[accKey] && productData[accKey].quantity) ? Number(productData[accKey].quantity) : 1;
        const unit = getAccessoryUnitPriceFromSelection(accKey, accSelectedOptionName);
        accessoriesTotal += unit * qty;
      }

      const totalPrice = materialCost + colorCost + accessoriesTotal;
      document.getElementById('price').textContent = totalPrice.toFixed(2);

      const messageLines = [
        `Hi, I want to order ${productData.name}.`,
        `Material Type: ${typeNameMap[selectedType] || selectedType}`,
        `Color: ${selectedColor || 'N/A'}`,
      ];

      for(const [accKey, accType] of Object.entries(selectedAccessories)) {
        messageLines.push(`${toTitleCase(accKey.replace(/([A-Z])/g, ' $1'))}: ${accType}`);
      }

      messageLines.push(`Price: RM ${totalPrice.toFixed(2)}`);

      const encodedMessage = encodeURIComponent(messageLines.join('\n'));
      document.getElementById('whatsappBtn').href = `https://wa.me/601111213149?text=${encodedMessage}`;
    }

    function initProductCarousel(product) {
      const carouselContainer = document.getElementById('productImageCarousel');
      carouselContainer.innerHTML = '';

      if (product.images && Array.isArray(product.images.extra)) {
        product.images.extra.forEach(imgUrl => {
          const slide = document.createElement('div');
          slide.classList.add('swiper-slide');
          slide.innerHTML = `<img src="${imgUrl}" alt="Product detail">`;
          carouselContainer.appendChild(slide);
        });
      }

      if (product.images) {
        Object.entries(product.images).forEach(([key, value]) => {
          if (key === 'extra') return;
          const slide = document.createElement('div');
          slide.classList.add('swiper-slide');
          slide.setAttribute('data-color', key.toLowerCase());
          slide.innerHTML = `<img src="${value}" alt="${key}">`;
          carouselContainer.appendChild(slide);
        });
      }

      if (swiper) {
        try { swiper.destroy(true, true); } catch (e) {}
        swiper = null;
      }

      swiper = new Swiper(".mySwiper", {
        loop: false,
        navigation: {
          nextEl: ".swiper-button-next",
          prevEl: ".swiper-button-prev"
        },
        pagination: {
          el: ".swiper-pagination",
          clickable: true
        },
        a11y: true,
      });

      swiper.on('slideChange', () => {
        const activeSlide = swiper.slides[swiper.activeIndex];
        if (!activeSlide) return;
        const color = activeSlide.getAttribute('data-color');
        if (color) {
          const colorSelect = document.getElementById('colorOptions');
          if (colorSelect) {
            colorSelect.value = color;
            selectedColor = color;
            updatePrice();
            validateProceedButton();
          }
        }
      });
    }

    function updateMainImage(color) {
      if (!productData) return;
      if (swiper) {
        const slides = document.querySelectorAll('.swiper-slide');
        const idx = Array.from(slides).findIndex(s => s.getAttribute('data-color') === (color || '').toLowerCase());
        if (idx >= 0) {
          swiper.slideTo(idx);
          return;
        }
        return;
      }
    }

    function validateProceedButton() {
      const proceedBtn = document.getElementById('whatsappBtn');

      if(!selectedType || !selectedColor) {
        proceedBtn.classList.remove('enabled');
        proceedBtn.setAttribute('disabled', 'true');
        return;
      }

      const typeKeys = getAllTypes();
      const excludedKeys = ['id', 'name', 'images', ...typeKeys];
      const accessoryKeys = Object.keys(productData).filter(key => !excludedKeys.includes(key));

      for(const accKey of accessoryKeys) {
        if(!selectedAccessories[accKey]) {
          proceedBtn.classList.remove('enabled');
          proceedBtn.setAttribute('disabled', 'true');
          return;
        }
      }

      proceedBtn.classList.add('enabled');
      proceedBtn.removeAttribute('disabled');
    }

    function toTitleCase(str) {
      return str.replace(/\b\w/g, c => c.toUpperCase());
    }

    fetchData();
  </script>
</body>
</html>
